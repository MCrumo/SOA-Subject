
==== MAIL ============================================================================
semaphores 	->	lista blocked no revisada por el scheduler..., esta bien lo del int destroyed?
    //sacar del ready, se encola en semaforo i hace un sched next (sem wait)
    //todos los sem destroy a 1 , lo tenemos el en task struct (sem destroy)
threads 	->  el wrapper tambe ha d'invocar la funcio que executara el thread; COM? -> Hem cridat la funció des de twrap, ho fem be?
terminate()	->	validar-la

user.c -> com eliminar el cursor de la tecla i la pantalla d'inici? -> no podem
    //no podrem, fer 80*i + x

======================================================================================
______________________________________________________________________________________
_______________________threads________________________________________________________
S'ha de fer init del TID al fork; gobl_TID = 1 es correcte -> ? 
Parametres de createthread ben passats -> SI
que ha de retornar int createthread() i terminate -> o 0 o -1
cada vex que llamemos dump_screen tendremos que crear un thread? createthread(dump_screen(*screen))-> ?
_______________________________________________________________________________________
_______________________screen_dump_____________________________________________________
quan ocupa un word i com es relaciona amb una pos de mem -> posMem=1B
com saber quin color correspon cada 0xXX -> fent proves
com passar el NUM_ROW/COLS al user.c -> no es pot
_______________________________________________________________________________________
_______________________keyboard________________________________________________________
keyboard_handler esta a entry.S i alla crida a keyboard_routine
keyboard_routine esta a interrupt.c i crida a printc_xy que esta a io.c
_______________________________________________________________________________________
_______________________semaphores______________________________________________________
apunts: https://github.com/hialvaro/ZeOS-SOA/blob/916caae118a6a33a6e794966ceda33b02049a84e/Teoria/SOA_Segundo_Parcial.md
sem1: 	https://github.com/acolominas/SOA/search?q=sem_wait
sem2:	https://github.com/4rnox/SOA-FIB/search?q=sem_wait
sem3:	https://github.com/miquel-gotanegra/SOA-FIB/search?q=sem_wait
_______________________________________________________________________________________
____________________alloc_14/11________________________________________________________
Comencem amb la implementacio de alloc()
Afegir a user-utils.S el wrapper ENTRY(alloc), salvat context i fa la call a sys_alloc().
Afegim a sys_call_table.S, a l'entrada 21 la crida a sistema sys_alloc()
Afegim a libc.h la funcio que declarem a alloc()
Afegim a sys.c la funcio sys_alloc()


==========================================================================================================
========================================= DEBUGAR BOCHS ==================================================
==========================================================================================================
DEBUGAR baix nivell bochs:
	objdump -d system | less  --> per buscar al less amb /nomBusqueda
	make emuldbg
	r 	-> print registers
	c 	-> continue
	print-stack 	-> print stack 32
	//la pila comença a partir de l'adreça 0x00017FFC
	b 0xaddr 	-> crar breackpoint

==========================================================================================================
========================================= PRACTICA JUEGO =================================================
==========================================================================================================
thread principal de videojuego, va hacer un spam de otro thread

thread1		
 |							   							thread2
 |														|
 | -> 	alloc() devolver la 							| -> dump_screen
 |		primera pag log 4KB 							|	interpreta matrix de 25fx80c
 |		libres, para dibujar la 						|	donde cada posicion hay dos B
 |		pantalla en un buffer que						|	1r->COLOR 2n->ASCII
 |		luego el 2o thread va a 						|
 |		dibujar											|
 |														|
 |	get_key(char *c) kbd_init buffer					|
 |			que guarda la teclas						|
 |			que se van pulsando							|
 |	get_key va a retornar la 1a tecla del buffer		|
 |														|
 |	una vez a dibujado el thread1 le va a passar		|
 |	al segundo thread									|
 |
 
 la lista se va a tener que implementar en exclusion mutua -> habra que implementar semaforos
 
==========================================================================================================
==========================================================================================================
==========================================================================================================

